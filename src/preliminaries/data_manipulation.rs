use candle_core::{Device, Tensor,DType,D};


/// ## 2.1.1 入门
///
/// 本节的目标是帮助读者了解并运行一些在阅读本书的过程中会用到的基本数值计算工具。
/// 如果你很难理解一些数学概念或库函数，请不要担心。 后面的章节将通过一些实际的例子来回顾这些内容。
/// 如果你已经具有相关经验，想要深入学习数学内容，可以跳过本节。
///
/// 本教程使用库与python库的对照
///
/// | python库 | rust库 |
/// | --- | --- |
/// | numpy | ndarray |
/// | pandas | polars |
/// | PyTorch | candle |
///
/// 引入 candle 库进行使用。
/// ```shell
/// cargo add --git https://github.com/huggingface/candle.git candle-core
/// ```
///
///<br>
/// 张量（Tensor）表示一个由数值组成的数组，这个数组可能有多个维度。
/// 具有一个轴的张量对应数学上的向量（vector）；
/// 具有两个轴的张量对应数学上的矩阵（matrix）；
/// 具有两个轴以上的张量没有特殊的数学名称。
///
/// 首先，我们可以使用 Tensor::arange 创建一个行向量 x。
/// 这个行向量包含以0开始的前12个数，由于 Tensor::arange 接收的类型不含 i32 ,我们默认创建为f64的浮点数。
/// 张量中的每个值都称为张量的 元素（element）。
/// 例如，张量 x 中有 12 个元素。除非额外指定，新的张量将存储在内存中，并采用基于CPU的计算。
///
/// ```rust
///use candle_core::{Device, Tensor};
///let device = Device::Cpu;
///let x = Tensor::arange(0., 12., &device)?;
///println!("{x}");
/// ```
/// ***
/// [ 0.,  1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  9., 10., 11.]
///
/// Tensor[[12], f64]
/// ***
///
///<br>
/// 张量的默认打印包含了值和形状，当然也可以通过张量的shape属性来访问张量（沿每个轴的长度）的形状 。
///
/// ```rust
///use candle_core::{Device, Tensor};
///let device = Device::Cpu;
///let x = Tensor::arange(0., 12., &device)?;
///println!("{:?}",x.shape());
/// ```
/// ***
/// [12]
/// ***
///
///<br>
/// 如果只想知道张量中元素的总数，即形状的所有元素乘积，可以检查它的大小（size）。
///
/// ```rust
///use candle_core::{Device, Tensor};
///let device = Device::Cpu;
///let x = Tensor::arange(0., 12., &device)?;
///println!("{:?}",x.elem_count());
/// ```
/// ***
/// 12
/// ***
///
///<br>
/// 要想改变一个张量的形状而不改变元素数量和元素值，可以调用reshape函数。
/// 例如，可以把张量x从形状为 [12] 的行向量转换为形状为 [3,4] 的矩阵。
/// 这个新的张量包含与转换前相同的值，但是它被看成一个3行4列的矩阵。
/// 要重点说明一下，虽然张量的形状发生了改变，但其元素值并没有变。
/// 注意，通过改变张量的形状，张量的大小不会改变。
///
/// ```rust
/// use candle_core::{Device, Tensor};
/// let device = Device::Cpu;
/// let x = Tensor::arange(0., 12., &device)?;
/// let x = x.reshape((3, 4))?;
/// println!("{x}");
///```
/// ***
/// [[ 0.,  1.,  2.,  3.],\
///  [ 4.,  5.,  6.,  7.],\
///  [ 8.,  9., 10., 11.]]\
/// Tensor[[3, 4], f64]
/// ***
///
///<br>
/// 有时，我们希望使用全0、全1、其他常量，或者从特定分布中随机采样的数字来初始化矩阵。
/// 我们可以创建一个形状为[2, 3, 4]的张量，其中所有元素都设置为0。代码如下：
///
/// ```rust
/// use candle_core::{Device, Tensor,DType};
/// let device = Device::Cpu;
/// let x = Tensor::zeros((2, 3, 4),DType::F32, &device)?;
/// println!("{x}");
///```
/// ***
/// [[[0., 0., 0., 0.],\
///   [0., 0., 0., 0.],\
///   [0., 0., 0., 0.]],\
///  [[0., 0., 0., 0.],\
///   [0., 0., 0., 0.],\
///   [0., 0., 0., 0.]]]\
/// Tensor[[2, 3, 4], f32]
/// ***
///
///<br>
/// 同样，我们可以创建一个形状为[2, 3, 4]的张量，其中所有元素都设置为1。代码如下：
///
/// ```rust
/// use candle_core::{Device, Tensor,DType};
/// let device = Device::Cpu;
/// let x = Tensor::ones((2, 3, 4),DType::F32, &device)?;
/// println!("{x}");
///```
///***
/// [[[1., 1., 1., 1.],\
///   [1., 1., 1., 1.],\
///   [1., 1., 1., 1.]],\
///  [[1., 1., 1., 1.],\
///   [1., 1., 1., 1.],\
///   [1., 1., 1., 1.]]]\
/// Tensor[[2, 3, 4], f32]\
/// ***
///
///<br>
/// 有时我们想通过从某个特定的概率分布中随机采样来得到张量中每个元素的值。
/// 例如，当我们构造数组来作为神经网络中的参数时，我们通常会随机初始化参数的值。
/// 以下代码创建一个形状为[3, 4]的张量。
/// 其中的每个元素都从均值为0、标准差为1的标准高斯分布（正态分布）中随机采样。
///
/// ```rust
/// use candle_core::{Device, Tensor,DType};
/// let device = Device::Cpu;
/// let x = Tensor::randn(0f32, 1., (3, 4), &device)?;
/// println!("{x}");
///```
/// ***
/// [[-1.2907, -1.2808,  0.2887,  0.8921],\
///  [-1.1277, -0.0230,  2.3441,  0.3280],\
///  [ 0.6468,  1.2457,  1.4576,  1.2184]]\
/// Tensor[[3, 4], f32]
/// ***
///
///<br>
///我们还可以通过提供包含数值的 Vec，来为所需张量中的每个元素赋予确定值。
/// 在这里，元素从前往后、从上到下的填入矩阵。
///
/// ```rust
/// use candle_core::{Device, Tensor,DType};
/// let device = Device::Cpu;
/// let vec = vec![1f64,2.,3.,4.,5.,6.,7.,8.,9.,10.,11.,12.];
/// let x = Tensor::from_vec(vec,(3,4), &device)?;
/// println!("{x}");
///```
///***
/// [[ 1.,  2.,  3.,  4.],\
///  [ 5.,  6.,  7.,  8.],\
///  [ 9., 10., 11., 12.]]\
/// Tensor[[3, 4], f64]
/// ***
///
///<br>
/// 可以看出candle的张量初始化较为严格，或者说candle库的使用有些严格，这种严格贯彻了rust的设计哲学。
/// 我们要清楚严格是为性能、安全作基石，多加练习，无需抗拒。
// #[test]
pub fn getting_started() -> Result<(), Box<dyn std::error::Error>> {
    Ok(())
}

/// ## 2.1.2 运算符
///
///
#[test]
pub fn operations() -> Result<(), Box<dyn std::error::Error>> {

    Ok(())
}